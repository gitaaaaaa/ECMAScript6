## 1.let命令
### 基本用法
let声明的变量只在它所在的代码块有效
```
{
  let a = 10;
  var b = 1;
}
// a
// ReferenceError: a is not defined.
// b
// 1
```
for循环的计数器，合适使用let命令
```
for (let i = 0; i < 10; i++) {
  //...
}
// console.log(i);
// ReferenceError: i is not defined
```

实例:重新认识for循环
```var
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10
```
```let
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
```
for循环的一个特别之:设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域
### 不存在变量提升 
1. let 关键词声明的变量不具备变量提升（hoisting）特性
### 暂时性死区（temporal dead zone，简称 TDZ） -go know typeof
```
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
```
ES6 规定暂时性死区和let、const语句不出现变量提升--以上是为了变量一定要在声明之后使用，否则就报错
### 不允许重复声明
```
// let不允许在相同作用域内，重复声明同一个变量。
// 报错
function func() {
  let a = 10;
  var a = 1;
}

// 报错
function func() {
  let a = 10;
  let a = 1;
}
// let不允许在相同作用域内，重复声明同一个变量。
function func(arg) {
  let arg; // 报错
}

function func(arg) {
  {
    let arg; // 不报错
  }
}
```
## 2.块级作用域
```
  ES5只有全局作用域和函数作用域
```
### 为什么需要块级作用域？
```
第一种场景，内层变量可能会覆盖外层变量。
var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    var tmp = 'hello world';
  }
}

f(); // undefined
变量提升，导致内层的tmp变量覆盖了外层的tmp变量。
```
```
第二种场景，用来计数的循环变量泄露为全局变量。

var s = 'hello';

for (var i = 0; i < s.length; i++) {
  console.log(s[i]);
}

console.log(i); // 5
变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。
```
###ES6 的块级作用域
```实例
function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5
}
```
ES6 允许块级作用域的任意嵌套。
```
{{{{
  {let insane = 'Hello World'}
  console.log(insane); // 报错
}}}};
外层作用域无法读取内层作用域的变量
{{{{
  let insane = 'Hello World';
  {let insane = 'Hello World'}
}}}};
内层作用域可以定义外层作用域的同名变量。
```
```
  ES5:
  广泛应用的立即执行函数表达式（IIFE）不再必要了
  // IIFE 写法
(function () {
  var tmp = ...;
  ...
}());

// 块级作用域写法
{
  let tmp = ...;
  ...
}
```
### 块级作用域与函数声明



## const
当使用常量 const 声明时，请使用大写变量，如：CAPITAL_CASING
const 在声明时必须被赋值
